{"type":"event","content":"User requested E2E automation for TaskAgent TUI: start app, Ctrl+N to Agent tab, submit 'list my files', wait for AI response (30s timeout or completion), then exit.","metadata":{"timestamp":"2025-10-29T14:30:00Z","tags":["requirement","e2e","automation"]},"timestamp":"2025-10-29T14:30:00Z"}
{"type":"fact","content":"Initial Expect-based approach failed: Ctrl+N and text input were batched by Node's stdin in raw mode, causing characters to merge (e.g., 'nlist my files\\n' instead of separate events). TextInput's onSubmit was never triggered because Enter key was consumed as part of the text stream.","metadata":{"confidence":0.95,"tags":["problem","expect","stdin","ink"],"source":"debugging"},"timestamp":"2025-10-29T15:00:00Z"}
{"type":"fact","content":"Root cause: stdin.setRawMode(true) was not being called by Ink in Expect/PTY environments. Added explicit call in ui.tsx to force raw mode for E2E testing.","metadata":{"confidence":0.9,"tags":["solution","stdin","ink"],"source":"implementation"},"timestamp":"2025-10-29T15:10:00Z"}
{"type":"fact","content":"Despite raw mode fix, Expect's send command batches characters before Node's event loop processes them. Delays (after 1000) and character-by-character sending (foreach char) did not solve the issue - all input still arrived as single event.","metadata":{"confidence":0.95,"tags":["problem","expect","timing","batching"],"source":"experimentation"},"timestamp":"2025-10-29T15:20:00Z"}
{"type":"skill","content":"For TUI E2E testing, avoid external keystroke simulation (Expect/tmux). Instead, implement internal automation engine: parse JSON steps from E2E_AUTOMATION_STEPS env var, execute actions (wait/press/switchTab/submit/exit) via application's own APIs, and log all steps to debug.log.","metadata":{"confidence":0.9,"tags":["pattern","testing","e2e","tui"],"source":"solution"},"timestamp":"2025-10-29T16:00:00Z"}
{"type":"fact","content":"Internal automation engine implemented with E2EAutomationStep union type supporting: wait (delay), press (ctrl+n), switchTab (direct), submit (with waitForStream), exit (scheduled). Uses useRef to persist handleSubmit/isStreaming/selectedTab across re-renders to prevent effect cleanup interruption.","metadata":{"confidence":0.95,"tags":["implementation","typescript","react","hooks"],"source":"code"},"timestamp":"2025-10-29T16:30:00Z"}
{"type":"fact","content":"Automation effect depends only on [e2eSteps, nonInteractiveInput] to prevent re-execution on state changes. handleSubmitRef/isStreamingRef/selectedTabRef updated via separate effects to always reference latest values without triggering automation cleanup.","metadata":{"confidence":0.9,"tags":["react","hooks","lifecycle","optimization"],"source":"implementation"},"timestamp":"2025-10-29T16:45:00Z"}
{"type":"fact","content":"waitForStream polls isStreamingRef.current and isProcessingQueueRef.current every 100ms with configurable timeout (default 30s). Returns true when both are false, or false on timeout.","metadata":{"confidence":0.9,"tags":["async","polling","streaming"],"source":"implementation"},"timestamp":"2025-10-29T17:00:00Z"}
{"type":"skill","content":"When implementing React automation engines: 1) Use useRef for all external dependencies (callbacks, state) to avoid re-triggering effects. 2) Keep effect dependencies minimal (only config/triggers). 3) Update refs in separate effects synced to their sources. 4) Use async IIFE for sequential async logic. 5) Return cleanup function to set cancelled flag.","metadata":{"confidence":0.85,"tags":["pattern","react","automation","best-practice"],"source":"lessons-learned"},"timestamp":"2025-10-29T17:10:00Z"}
{"type":"fact","content":"Expect script simplified to: 1) Set E2E_SENTINEL=1 and E2E_AUTOMATION_STEPS env vars. 2) Spawn yarn start. 3) Wait for process exit (timeout 60s). 4) Report completion. All interaction logic moved to application internals.","metadata":{"confidence":0.95,"tags":["expect","architecture","separation-of-concerns"],"source":"refactor"},"timestamp":"2025-10-29T17:15:00Z"}
{"type":"fact","content":"Debug logging made conditional on E2E_SENTINEL env var to avoid noise in normal usage. Covers: raw input events, Ctrl+N detection, TextInput onSubmit, automation steps, Agent stream events.","metadata":{"confidence":0.9,"tags":["logging","debugging","observability"],"source":"implementation"},"timestamp":"2025-10-29T17:18:00Z"}
{"type":"fact","content":"Final verification (debug.log analysis): Automation completed in ~26s with full chain: wait 500ms → press ctrl+n → submit 'list my files' → Agent called Bash tool (ls -la) → streamed formatted response (1127 chars) → waitForStream returned true → exit code 0.","metadata":{"confidence":1.0,"tags":["verification","success","e2e"],"source":"testing"},"timestamp":"2025-10-29T17:26:00Z"}
{"type":"fact","content":"TUI testing industry practices: 1) Golden master/snapshot (VHS, ink-testing-library). 2) Script-driven (Expect, tmux). 3) Embedded test API (our approach, similar to Vim feedkeys/Textual pilot). 4) Record/replay (asciinema). 5) Containerized E2E (Testcontainers). 6) Property-based testing. Ink official focuses on component-level unit tests with synchronous mocks.","metadata":{"confidence":0.85,"tags":["industry","testing","tui","comparison"],"source":"research"},"timestamp":"2025-10-29T17:30:00Z"}
{"type":"fact","content":"Ink official testing library (ink-testing-library) provides: lastFrame() for text snapshots, stdin.write() for sync input simulation, rerender/unmount. Suitable for component-level unit tests but cannot test async streams, tool calls, or cross-component state flow. Complements rather than replaces E2E automation.","metadata":{"confidence":0.9,"tags":["ink","testing","limitations","complementary"],"source":"comparison"},"timestamp":"2025-10-29T17:32:00Z"}
{"type":"fact","content":"Package.json script changed from 'scripts/e2e-experiment.expect' (requires chmod +x) to 'expect scripts/e2e-experiment.expect --' (no execute permission needed). Treats .expect file as configuration/script to be interpreted rather than executable.","metadata":{"confidence":0.95,"tags":["fix","permissions","architecture"],"source":"refactor"},"timestamp":"2025-10-29T17:35:00Z"}
{"type":"skill","content":"For test scripts requiring interpreters (expect, python, node): prefer 'interpreter path/to/script' in package.json over making script executable. Avoids cross-platform permission issues, git attribute complexities, and clarifies that file is data/config rather than binary.","metadata":{"confidence":0.85,"tags":["best-practice","testing","cross-platform"],"source":"lessons-learned"},"timestamp":"2025-10-29T17:36:00Z"}

